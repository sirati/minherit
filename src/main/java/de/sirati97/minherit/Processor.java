package de.sirati97.minherit;

import org.objectweb.asm.*;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.util.TraceClassVisitor;

import java.io.IOException;
import java.io.PrintWriter;
import java.lang.invoke.MethodHandles;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

import static org.objectweb.asm.ClassReader.*;
import static org.objectweb.asm.ClassWriter.*;
import static org.objectweb.asm.Opcodes.*;
import static org.objectweb.asm.Type.*;

public class Processor {
    private final static Map<Class<?>, Supplier<IMapper>[]> mapperSuppliers = new HashMap<>();

    public static Supplier<IMapper>[] getMapperSupplier(Class<?> clazz) {
        System.out.println("access private for clazz: " + clazz.getName());
        return mapperSuppliers.remove(clazz);
    }

    @SuppressWarnings("unchecked")
    public static  <TResult extends TBase, TInterface, TBase, TParent extends TBase, TRefImpl extends TInterface>
    Class<TResult> unify(Class<TInterface> interfaceClass, Class<TParent> parentClass, Class<TRefImpl> implClass, Supplier<IMapper> mapperSupplier) {
        Type implType = Type.getType(implClass);
        Type parentType = Type.getType(parentClass);
        Type interfaceType = Type.getType(interfaceClass);

        try {
            ClassNode parentCN = getNode(parentClass);
            ClassNode result = getNode(implClass);

            //ClassNode result = implCN;
            result.version = Math.max(parentCN.version, result.version);
            result.access = ACC_PUBLIC;

            String name = conv(implClass.getPackage().getName()) + "/autogenerated/" + parentClass.getSimpleName() + "Ext" + interfaceClass.getSimpleName();
            String oldSuperName = result.superName;
            String oldName = result.name;
            result.superName = parentType.getInternalName();
            result.name = name;

            MethodNode ctor = null;
            MethodNode clinit = null;
            MethodNode ctorNewSuper = null;

            for (MethodNode method:parentCN.methods) {

                if ("<init>".equals(method.name)) {
                    ctorNewSuper = method;
                }
            }
            for (MethodNode method:result.methods) {
                if ("<init>".equals(method.name)) {
                    ctor = method;
                } else if ("<clinit>".equals(method.name)) {
                    clinit = method;
                }
                Iterable<AbstractInsnNode> iterable = method.instructions::iterator;
                for (AbstractInsnNode inst:iterable) {
                    remapThisSuper(inst, oldSuperName, oldName, result.superName, result.name);
                }
            }
            for(InnerClassNode innerClassNode: result.innerClasses) {
                /*for (MethodNode method:innerClassNode.methods) {
                    Iterable<AbstractInsnNode> iterable = method.instructions::iterator;
                    for (AbstractInsnNode inst:iterable) {
                        remapThisSuper(inst, oldSuperName, oldName, result.superName, result.name);
                    }
                }*/
            }
            if (clinit == null) {
                clinit = new MethodNode(ACC_STATIC, "<clinit>", "()V", null, null);
                setLineNumber(clinit, Integer.MAX_VALUE);
                clinit.visitInsn(RETURN);
                clinit.visitEnd();
                result.methods.add(clinit);
            }

            //Consumer<Class<?>> fieldInit = (c)->{};
            //fieldInit = fieldInit.andThen(
            ctorMapper(Type.getArgumentTypes(ctor.desc), Type.getArgumentTypes(ctorNewSuper.desc), 0, mapperSupplier, result, ctor, clinit);//)


            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);
            result.accept(cw);
            byte[] b = cw.toByteArray();

            /*TraceClassVisitor pcv = new TraceClassVisitor(new PrintWriter(System.out));
            ClassReader cr = new ClassReader(b, 0, b.length);
            cr.accept(pcv, EXPAND_FRAMES);/**/

            Class<TResult> resultClass = (Class<TResult>)  loadClass(b, result.name.replace('/','.'), implClass.getClassLoader());
            mapperSuppliers.put(resultClass, new Supplier[]{mapperSupplier});
            //fieldInit.accept(resultClass);
            return resultClass;
        } catch (ClassNotFoundException | NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
            throw new IllegalStateException(e);
        }
    }

    private static void remapThisSuper(AbstractInsnNode inst, String oldSuperName, String oldName, String superName, String name) {
        if (inst instanceof MethodInsnNode) {
            if (oldSuperName.equals(((MethodInsnNode) inst).owner)) {
                ((MethodInsnNode) inst).owner = superName;
            }
            if (oldName.equals(((MethodInsnNode) inst).owner)) {
                ((MethodInsnNode) inst).owner = name;
            }
        } else if (inst instanceof FieldInsnNode) {
            if (oldSuperName.equals(((FieldInsnNode) inst).owner)) {
                ((FieldInsnNode) inst).owner = superName;
            }
            if (oldName.equals(((FieldInsnNode) inst).owner)) {
                ((FieldInsnNode) inst).owner = name;
            }
        }
    }

    private static final Type IMapperType = getType(IMapper.class);
    private static final Type SupplierType = getType(Supplier.class);
    private static final Type SupplierArrayType = getType(Supplier[].class);
    private static final Type ObjectType = getType(Object.class);
    private static final Type ProcessorType = getType(Processor.class);
    private static final Type ClassType = getType(Class.class);
    private static final String[] EMPTY_ARRAY = new String[0];
    protected static void ctorMapper(Type[] from, Type[] to, int mapperId, Supplier<IMapper> mapperSupplier, ClassNode classNode, MethodNode originalCtor, MethodNode clinit) {
        Type mapperSupplierType = getType(mapperSupplier.getClass());
        String fieldname = "_minherit_autogen_ctor_mapper_factory_" + mapperId;
        FieldNode mapperFactory = new FieldNode(ACC_PUBLIC | ACC_STATIC | ACC_FINAL, fieldname, SupplierType.getDescriptor(), null, null);
        classNode.fields.add(mapperFactory);
        //wrint in
        MethodNode adapterIn = new MethodNode(originalCtor.access, "<init>", originalCtor.desc, originalCtor.signature, EMPTY_ARRAY);
        setLineNumber(adapterIn, Integer.MAX_VALUE);

        adapterIn.visitVarInsn(ALOAD, 0);
        adapterIn.visitFieldInsn(GETSTATIC, classNode.name, fieldname, SupplierType.getDescriptor());
        adapterIn.visitMethodInsn(INVOKEINTERFACE, SupplierType.getInternalName(), "get", Type.getMethodDescriptor(ObjectType), true);
        adapterIn.visitTypeInsn(CHECKCAST, IMapperType.getInternalName());

        for (int i = 0; i < from.length; i++) {
            Type fromType = from[i];
            Type paramType = fromType.getSort() == OBJECT?ObjectType:fromType;

            loadIntConst(adapterIn, i);
            adapterIn.visitVarInsn(fromType.getOpcode(ILOAD), i+1);
            adapterIn.visitMethodInsn(INVOKEINTERFACE, IMapperType.getInternalName(), mapperIn(paramType), Type.getMethodDescriptor(IMapperType, INT_TYPE, paramType), true);
        }
        adapterIn.visitMethodInsn(INVOKESPECIAL, classNode.name, "<init>", "(Lde/sirati97/minherit/IMapper;)V", false);

        Iterable<AbstractInsnNode> iterable = originalCtor.instructions::iterator;
        boolean found = false;
        for (AbstractInsnNode inst:iterable) {
            if (found) {
                inst.accept(adapterIn);
            }
            if (inst instanceof MethodInsnNode) {
                MethodInsnNode methodInsnNode = (MethodInsnNode) inst;
                if (methodInsnNode.getOpcode() == INVOKESPECIAL && "<init>".equals(methodInsnNode.name)) {
                    found = true;
                }
            }
        }
        adapterIn.visitMaxs(0,0); //apparently this makes it calc it
        adapterIn.visitEnd();
        classNode.methods.remove(originalCtor);
        classNode.methods.add(adapterIn);

        //write out
        MethodNode adapterOut = new MethodNode(ACC_PRIVATE, "<init>", getMethodDescriptor(VOID_TYPE, IMapperType), null, EMPTY_ARRAY);
        setLineNumber(adapterOut, Integer.MAX_VALUE);
        adapterOut.visitVarInsn(ALOAD, 0);
        for (int i = 0; i < to.length; i++) {
            Type toType = to[i];
            adapterOut.visitVarInsn(ALOAD, 1);
            loadIntConst(adapterOut, i);

            Type returnType = toType.getSort() == OBJECT?ObjectType:toType;
            adapterOut.instructions.add(new MethodInsnNode(INVOKEINTERFACE, IMapperType.getInternalName(), mapperOut(returnType), Type.getMethodDescriptor(returnType, INT_TYPE), true));
            if (toType.getSort() == OBJECT) {
                adapterOut.visitTypeInsn(CHECKCAST, toType.getInternalName());
            }
        }

        adapterOut.visitMethodInsn(INVOKESPECIAL, classNode.superName, "<init>", Type.getMethodDescriptor(VOID_TYPE, to), false);
        adapterOut.visitInsn(RETURN);
        adapterOut.visitMaxs(0,0); //apparently this makes it calc it
        adapterOut.visitEnd();

        classNode.methods.add(adapterOut);



         iterable = clinit.instructions::iterator;
        AbstractInsnNode entryPoint = null;
        for (AbstractInsnNode inst:iterable) {
            if (inst.getOpcode() == RETURN) {
                do {
                    inst = inst.getPrevious();
                } while (!(inst instanceof LabelNode));
                entryPoint = inst.getPrevious();
                if (entryPoint == null) {
                    entryPoint = new InsnNode(NOP);
                    clinit.instructions.insert(entryPoint);
                }
                break;
            }
        }

        MethodNode insertion = new MethodNode(0,"","","", null); //
        Label l0 = setLineNumber(insertion, Integer.MAX_VALUE);
        insertion.visitLdcInsn(Type.getObjectType(classNode.name));
        insertion.visitMethodInsn(INVOKESTATIC, ProcessorType.getInternalName(), "getMapperSupplier", Type.getMethodDescriptor(SupplierArrayType, ClassType), false);
        insertion.visitVarInsn(ASTORE, 0); //todo this index might create problems
        //todo find entry point for second access
        insertion.visitVarInsn(ALOAD, 0);
        insertion.visitInsn(ICONST_0);
        insertion.visitInsn(AALOAD);
        insertion.visitFieldInsn(PUTSTATIC, classNode.name, fieldname, SupplierType.getDescriptor());

        insertion.visitLocalVariable("_minherit_autogen_ctor_mapper_factory_array", SupplierArrayType.getDescriptor(), null, l0, l0, 0);
        insertion.visitMaxs(0, 0);
        insertion.visitEnd();

        clinit.instructions.insert(entryPoint, insertion.instructions);
        
        /*return (clazz) -> {
            try {
                clazz.getDeclaredField(fieldname).set(null, mapperSupplier);
            } catch (NoSuchFieldException | IllegalAccessException e) {
                throw new IllegalStateException(e);
            }
        };*/
    }

    public static Label setLineNumber(MethodNode mn, int line) {
        Label l0 = new Label();
        mn.visitLabel(l0);
        mn.visitLineNumber(line, l0);
        return l0;
    }

    private static void loadIntConst(MethodNode node, int value) {
        if (value >= 0 && value <= 5) {
            int op;
            switch (value) {
                case 0:op=ICONST_0;break;
                case 1:op=ICONST_1;break;
                case 2:op=ICONST_2;break;
                case 3:op=ICONST_3;break;
                case 4:op=ICONST_4;break;
                case 5:op=ICONST_5;break;
                default:
                    throw new IllegalStateException("Unexpected value: " + value);
            }
            node.visitInsn(op);
        } else  {
            node.visitVarInsn(BIPUSH, value);
        }

    }

    private static String mapperOut(Type type) {
        switch (type.getSort()) {
            case BOOLEAN: return "outBoolean";
            
            case BYTE: return "outByte";
            case SHORT: return "outShort";
            case INT: return "outInt";
            case Type.LONG: return "outLong";
            
            case Type.FLOAT: return "outFloat";
            case Type.DOUBLE: return "outDouble";
            
            case CHAR: return "outChar";
            default: return "outObj";
        }
    }


    private static String mapperIn(Type type) {
        switch (type.getSort()) {
            case BOOLEAN: return "inBoolean";

            case BYTE: return "inByte";
            case SHORT: return "inShort";
            case INT: return "inInt";
            case Type.LONG: return "inLong";

            case Type.FLOAT: return "inFloat";
            case Type.DOUBLE: return "inDouble";

            case CHAR: return "inChar";
            default: return "inObj";
        }
    }
    
    protected static String conv(String in) {
        return in.replace('.', '/');
    }

    public static Function<Class<?>, ClassReader> readClass = (clazz) -> {
        try {
            return new ClassReader(clazz.getResourceAsStream(clazz.getSimpleName() + ".class"));
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    };

    public static ClassNode getNode(Class<?> clazz) {
        ClassNode cn = new ClassNode();
        ClassReader cr = readClass.apply(clazz);
        cr.accept(cn, EXPAND_FRAMES);
        return cn;
    }


    public static Class<?> loadClass(byte[] bytecode, String name, ClassLoader classLoader)  throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, ClassNotFoundException {
        //MethodHandles.publicLookup().in(implClass);


        Object[] args = new Object[] {
                null, bytecode, 0, bytecode.length
        };
        Method m = ClassLoader.class.getDeclaredMethod("defineClass", String.class, byte[].class, int.class, int.class);
        m.setAccessible(true);
        return (Class<?>) m.invoke(classLoader, args);/**/
        /*ByteClassLoader byteClassLoader = classloaders.computeIfAbsent(classLoader, classLoader1 -> new ByteClassLoader(classLoader));
        return byteClassLoader.loadClass(name, bytecode);/**/
    }

}
